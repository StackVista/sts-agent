#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys

from thrift.transport import TTransport


class TThreadDumpType(object):
    TARGET = 0
    PENDING = 1

    _VALUES_TO_NAMES = {
        0: "TARGET",
        1: "PENDING",
    }

    _NAMES_TO_VALUES = {
        "TARGET": 0,
        "PENDING": 1,
    }


class TThreadState(object):
    NEW = 0
    RUNNABLE = 1
    BLOCKED = 2
    WAITING = 3
    TIMED_WAITING = 4
    TERMINATED = 5
    UNKNOWN = 6

    _VALUES_TO_NAMES = {
        0: "NEW",
        1: "RUNNABLE",
        2: "BLOCKED",
        3: "WAITING",
        4: "TIMED_WAITING",
        5: "TERMINATED",
        6: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "NEW": 0,
        "RUNNABLE": 1,
        "BLOCKED": 2,
        "WAITING": 3,
        "TIMED_WAITING": 4,
        "TERMINATED": 5,
        "UNKNOWN": 6,
    }


class TRouteResult(object):
    OK = 0
    BAD_REQUEST = 200
    EMPTY_REQUEST = 201
    NOT_SUPPORTED_REQUEST = 202
    BAD_RESPONSE = 210
    EMPTY_RESPONSE = 211
    NOT_SUPPORTED_RESPONSE = 212
    TIMEOUT = 220
    NOT_FOUND = 230
    NOT_ACCEPTABLE = 240
    NOT_SUPPORTED_SERVICE = 241
    UNKNOWN = -1

    _VALUES_TO_NAMES = {
        0: "OK",
        200: "BAD_REQUEST",
        201: "EMPTY_REQUEST",
        202: "NOT_SUPPORTED_REQUEST",
        210: "BAD_RESPONSE",
        211: "EMPTY_RESPONSE",
        212: "NOT_SUPPORTED_RESPONSE",
        220: "TIMEOUT",
        230: "NOT_FOUND",
        240: "NOT_ACCEPTABLE",
        241: "NOT_SUPPORTED_SERVICE",
        -1: "UNKNOWN",
    }

    _NAMES_TO_VALUES = {
        "OK": 0,
        "BAD_REQUEST": 200,
        "EMPTY_REQUEST": 201,
        "NOT_SUPPORTED_REQUEST": 202,
        "BAD_RESPONSE": 210,
        "EMPTY_RESPONSE": 211,
        "NOT_SUPPORTED_RESPONSE": 212,
        "TIMEOUT": 220,
        "NOT_FOUND": 230,
        "NOT_ACCEPTABLE": 240,
        "NOT_SUPPORTED_SERVICE": 241,
        "UNKNOWN": -1,
    }


class TCommandThreadDump(object):
    """
    Attributes:
     - type
     - name
     - pendingTimeMillis
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'type', None, 0, ),  # 1
        (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
        (3, TType.I64, 'pendingTimeMillis', None, None, ),  # 3
    )

    def __init__(self, type=thrift_spec[1][4], name=None, pendingTimeMillis=None,):
        self.type = type
        self.name = name
        self.pendingTimeMillis = pendingTimeMillis

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.pendingTimeMillis = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCommandThreadDump')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 1)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.pendingTimeMillis is not None:
            oprot.writeFieldBegin('pendingTimeMillis', TType.I64, 3)
            oprot.writeI64(self.pendingTimeMillis)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMonitorInfo(object):
    """
    Attributes:
     - stackDepth
     - stackFrame
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'stackDepth', None, None, ),  # 1
        (2, TType.STRING, 'stackFrame', 'UTF8', None, ),  # 2
    )

    def __init__(self, stackDepth=None, stackFrame=None,):
        self.stackDepth = stackDepth
        self.stackFrame = stackFrame

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.stackDepth = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stackFrame = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TMonitorInfo')
        if self.stackDepth is not None:
            oprot.writeFieldBegin('stackDepth', TType.I32, 1)
            oprot.writeI32(self.stackDepth)
            oprot.writeFieldEnd()
        if self.stackFrame is not None:
            oprot.writeFieldBegin('stackFrame', TType.STRING, 2)
            oprot.writeString(self.stackFrame.encode('utf-8') if sys.version_info[0] == 2 else self.stackFrame)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TThreadDump(object):
    """
    Attributes:
     - threadName
     - threadId
     - blockedTime
     - blockedCount
     - waitedTime
     - waitedCount
     - lockName
     - lockOwnerId
     - lockOwnerName
     - inNative
     - suspended
     - threadState
     - stackTrace
     - lockedMonitors
     - lockedSynchronizers
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'threadName', 'UTF8', None, ),  # 1
        (2, TType.I64, 'threadId', None, None, ),  # 2
        (3, TType.I64, 'blockedTime', None, None, ),  # 3
        (4, TType.I64, 'blockedCount', None, None, ),  # 4
        (5, TType.I64, 'waitedTime', None, None, ),  # 5
        (6, TType.I64, 'waitedCount', None, None, ),  # 6
        (7, TType.STRING, 'lockName', 'UTF8', None, ),  # 7
        (8, TType.I64, 'lockOwnerId', None, None, ),  # 8
        (9, TType.STRING, 'lockOwnerName', 'UTF8', None, ),  # 9
        (10, TType.BOOL, 'inNative', None, None, ),  # 10
        (11, TType.BOOL, 'suspended', None, None, ),  # 11
        (12, TType.I32, 'threadState', None, None, ),  # 12
        (13, TType.LIST, 'stackTrace', (TType.STRING, 'UTF8', False), None, ),  # 13
        (14, TType.LIST, 'lockedMonitors', (TType.STRUCT, (TMonitorInfo, TMonitorInfo.thrift_spec), False), None, ),  # 14
        (15, TType.LIST, 'lockedSynchronizers', (TType.STRING, 'UTF8', False), None, ),  # 15
    )

    def __init__(self, threadName=None, threadId=None, blockedTime=None, blockedCount=None, waitedTime=None, waitedCount=None, lockName=None, lockOwnerId=None, lockOwnerName=None, inNative=None, suspended=None, threadState=None, stackTrace=None, lockedMonitors=None, lockedSynchronizers=None,):
        self.threadName = threadName
        self.threadId = threadId
        self.blockedTime = blockedTime
        self.blockedCount = blockedCount
        self.waitedTime = waitedTime
        self.waitedCount = waitedCount
        self.lockName = lockName
        self.lockOwnerId = lockOwnerId
        self.lockOwnerName = lockOwnerName
        self.inNative = inNative
        self.suspended = suspended
        self.threadState = threadState
        self.stackTrace = stackTrace
        self.lockedMonitors = lockedMonitors
        self.lockedSynchronizers = lockedSynchronizers

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.threadName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.threadId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.blockedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.blockedCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.waitedTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I64:
                    self.waitedCount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.lockName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.lockOwnerId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.lockOwnerName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.BOOL:
                    self.inNative = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.suspended = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.threadState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.LIST:
                    self.stackTrace = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.stackTrace.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.LIST:
                    self.lockedMonitors = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = TMonitorInfo()
                        _elem11.read(iprot)
                        self.lockedMonitors.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.LIST:
                    self.lockedSynchronizers = []
                    (_etype15, _size12) = iprot.readListBegin()
                    for _i16 in range(_size12):
                        _elem17 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.lockedSynchronizers.append(_elem17)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TThreadDump')
        if self.threadName is not None:
            oprot.writeFieldBegin('threadName', TType.STRING, 1)
            oprot.writeString(self.threadName.encode('utf-8') if sys.version_info[0] == 2 else self.threadName)
            oprot.writeFieldEnd()
        if self.threadId is not None:
            oprot.writeFieldBegin('threadId', TType.I64, 2)
            oprot.writeI64(self.threadId)
            oprot.writeFieldEnd()
        if self.blockedTime is not None:
            oprot.writeFieldBegin('blockedTime', TType.I64, 3)
            oprot.writeI64(self.blockedTime)
            oprot.writeFieldEnd()
        if self.blockedCount is not None:
            oprot.writeFieldBegin('blockedCount', TType.I64, 4)
            oprot.writeI64(self.blockedCount)
            oprot.writeFieldEnd()
        if self.waitedTime is not None:
            oprot.writeFieldBegin('waitedTime', TType.I64, 5)
            oprot.writeI64(self.waitedTime)
            oprot.writeFieldEnd()
        if self.waitedCount is not None:
            oprot.writeFieldBegin('waitedCount', TType.I64, 6)
            oprot.writeI64(self.waitedCount)
            oprot.writeFieldEnd()
        if self.lockName is not None:
            oprot.writeFieldBegin('lockName', TType.STRING, 7)
            oprot.writeString(self.lockName.encode('utf-8') if sys.version_info[0] == 2 else self.lockName)
            oprot.writeFieldEnd()
        if self.lockOwnerId is not None:
            oprot.writeFieldBegin('lockOwnerId', TType.I64, 8)
            oprot.writeI64(self.lockOwnerId)
            oprot.writeFieldEnd()
        if self.lockOwnerName is not None:
            oprot.writeFieldBegin('lockOwnerName', TType.STRING, 9)
            oprot.writeString(self.lockOwnerName.encode('utf-8') if sys.version_info[0] == 2 else self.lockOwnerName)
            oprot.writeFieldEnd()
        if self.inNative is not None:
            oprot.writeFieldBegin('inNative', TType.BOOL, 10)
            oprot.writeBool(self.inNative)
            oprot.writeFieldEnd()
        if self.suspended is not None:
            oprot.writeFieldBegin('suspended', TType.BOOL, 11)
            oprot.writeBool(self.suspended)
            oprot.writeFieldEnd()
        if self.threadState is not None:
            oprot.writeFieldBegin('threadState', TType.I32, 12)
            oprot.writeI32(self.threadState)
            oprot.writeFieldEnd()
        if self.stackTrace is not None:
            oprot.writeFieldBegin('stackTrace', TType.LIST, 13)
            oprot.writeListBegin(TType.STRING, len(self.stackTrace))
            for iter18 in self.stackTrace:
                oprot.writeString(iter18.encode('utf-8') if sys.version_info[0] == 2 else iter18)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lockedMonitors is not None:
            oprot.writeFieldBegin('lockedMonitors', TType.LIST, 14)
            oprot.writeListBegin(TType.STRUCT, len(self.lockedMonitors))
            for iter19 in self.lockedMonitors:
                iter19.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.lockedSynchronizers is not None:
            oprot.writeFieldBegin('lockedSynchronizers', TType.LIST, 15)
            oprot.writeListBegin(TType.STRING, len(self.lockedSynchronizers))
            for iter20 in self.lockedSynchronizers:
                oprot.writeString(iter20.encode('utf-8') if sys.version_info[0] == 2 else iter20)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TThreadLightDump(object):
    """
    Attributes:
     - threadName
     - threadId
     - threadState
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'threadName', 'UTF8', None, ),  # 1
        (2, TType.I64, 'threadId', None, None, ),  # 2
        (3, TType.I32, 'threadState', None, None, ),  # 3
    )

    def __init__(self, threadName=None, threadId=None, threadState=None,):
        self.threadName = threadName
        self.threadId = threadId
        self.threadState = threadState

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.threadName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.threadId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.threadState = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TThreadLightDump')
        if self.threadName is not None:
            oprot.writeFieldBegin('threadName', TType.STRING, 1)
            oprot.writeString(self.threadName.encode('utf-8') if sys.version_info[0] == 2 else self.threadName)
            oprot.writeFieldEnd()
        if self.threadId is not None:
            oprot.writeFieldBegin('threadId', TType.I64, 2)
            oprot.writeI64(self.threadId)
            oprot.writeFieldEnd()
        if self.threadState is not None:
            oprot.writeFieldBegin('threadState', TType.I32, 3)
            oprot.writeI32(self.threadState)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandThreadDumpResponse(object):
    """
    Attributes:
     - threadDumps
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'threadDumps', (TType.STRUCT, (TThreadDump, TThreadDump.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, threadDumps=None,):
        self.threadDumps = threadDumps

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.threadDumps = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TThreadDump()
                        _elem26.read(iprot)
                        self.threadDumps.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCommandThreadDumpResponse')
        if self.threadDumps is not None:
            oprot.writeFieldBegin('threadDumps', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.threadDumps))
            for iter27 in self.threadDumps:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadCount(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCmdActiveThreadCount')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadCountRes(object):
    """
    Attributes:
     - histogramSchemaType
     - activeThreadCount
     - timeStamp
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'histogramSchemaType', None, None, ),  # 1
        (2, TType.LIST, 'activeThreadCount', (TType.I32, None, False), None, ),  # 2
        (3, TType.I64, 'timeStamp', None, None, ),  # 3
    )

    def __init__(self, histogramSchemaType=None, activeThreadCount=None, timeStamp=None,):
        self.histogramSchemaType = histogramSchemaType
        self.activeThreadCount = activeThreadCount
        self.timeStamp = timeStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.histogramSchemaType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.activeThreadCount = []
                    (_etype31, _size28) = iprot.readListBegin()
                    for _i32 in range(_size28):
                        _elem33 = iprot.readI32()
                        self.activeThreadCount.append(_elem33)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timeStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCmdActiveThreadCountRes')
        if self.histogramSchemaType is not None:
            oprot.writeFieldBegin('histogramSchemaType', TType.I32, 1)
            oprot.writeI32(self.histogramSchemaType)
            oprot.writeFieldEnd()
        if self.activeThreadCount is not None:
            oprot.writeFieldBegin('activeThreadCount', TType.LIST, 2)
            oprot.writeListBegin(TType.I32, len(self.activeThreadCount))
            for iter34 in self.activeThreadCount:
                oprot.writeI32(iter34)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timeStamp is not None:
            oprot.writeFieldBegin('timeStamp', TType.I64, 3)
            oprot.writeI64(self.timeStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TActiveThreadDump(object):
    """
    Attributes:
     - startTime
     - localTraceId
     - threadDump
     - sampled
     - transactionId
     - entryPoint
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'startTime', None, None, ),  # 1
        (2, TType.I64, 'localTraceId', None, None, ),  # 2
        (3, TType.STRUCT, 'threadDump', (TThreadDump, TThreadDump.thrift_spec), None, ),  # 3
        (4, TType.BOOL, 'sampled', None, False, ),  # 4
        (5, TType.STRING, 'transactionId', 'UTF8', None, ),  # 5
        (6, TType.STRING, 'entryPoint', 'UTF8', None, ),  # 6
    )

    def __init__(self, startTime=None, localTraceId=None, threadDump=None, sampled=thrift_spec[4][4], transactionId=None, entryPoint=None,):
        self.startTime = startTime
        self.localTraceId = localTraceId
        self.threadDump = threadDump
        self.sampled = sampled
        self.transactionId = transactionId
        self.entryPoint = entryPoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.localTraceId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.threadDump = TThreadDump()
                    self.threadDump.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.sampled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.transactionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.entryPoint = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TActiveThreadDump')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.localTraceId is not None:
            oprot.writeFieldBegin('localTraceId', TType.I64, 2)
            oprot.writeI64(self.localTraceId)
            oprot.writeFieldEnd()
        if self.threadDump is not None:
            oprot.writeFieldBegin('threadDump', TType.STRUCT, 3)
            self.threadDump.write(oprot)
            oprot.writeFieldEnd()
        if self.sampled is not None:
            oprot.writeFieldBegin('sampled', TType.BOOL, 4)
            oprot.writeBool(self.sampled)
            oprot.writeFieldEnd()
        if self.transactionId is not None:
            oprot.writeFieldBegin('transactionId', TType.STRING, 5)
            oprot.writeString(self.transactionId.encode('utf-8') if sys.version_info[0] == 2 else self.transactionId)
            oprot.writeFieldEnd()
        if self.entryPoint is not None:
            oprot.writeFieldBegin('entryPoint', TType.STRING, 6)
            oprot.writeString(self.entryPoint.encode('utf-8') if sys.version_info[0] == 2 else self.entryPoint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TActiveThreadLightDump(object):
    """
    Attributes:
     - startTime
     - localTraceId
     - threadDump
     - sampled
     - transactionId
     - entryPoint
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I64, 'startTime', None, None, ),  # 1
        (2, TType.I64, 'localTraceId', None, None, ),  # 2
        (3, TType.STRUCT, 'threadDump', (TThreadLightDump, TThreadLightDump.thrift_spec), None, ),  # 3
        (4, TType.BOOL, 'sampled', None, False, ),  # 4
        (5, TType.STRING, 'transactionId', 'UTF8', None, ),  # 5
        (6, TType.STRING, 'entryPoint', 'UTF8', None, ),  # 6
    )

    def __init__(self, startTime=None, localTraceId=None, threadDump=None, sampled=thrift_spec[4][4], transactionId=None, entryPoint=None,):
        self.startTime = startTime
        self.localTraceId = localTraceId
        self.threadDump = threadDump
        self.sampled = sampled
        self.transactionId = transactionId
        self.entryPoint = entryPoint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.localTraceId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.threadDump = TThreadLightDump()
                    self.threadDump.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.sampled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.transactionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.entryPoint = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TActiveThreadLightDump')
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 1)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.localTraceId is not None:
            oprot.writeFieldBegin('localTraceId', TType.I64, 2)
            oprot.writeI64(self.localTraceId)
            oprot.writeFieldEnd()
        if self.threadDump is not None:
            oprot.writeFieldBegin('threadDump', TType.STRUCT, 3)
            self.threadDump.write(oprot)
            oprot.writeFieldEnd()
        if self.sampled is not None:
            oprot.writeFieldBegin('sampled', TType.BOOL, 4)
            oprot.writeBool(self.sampled)
            oprot.writeFieldEnd()
        if self.transactionId is not None:
            oprot.writeFieldBegin('transactionId', TType.STRING, 5)
            oprot.writeString(self.transactionId.encode('utf-8') if sys.version_info[0] == 2 else self.transactionId)
            oprot.writeFieldEnd()
        if self.entryPoint is not None:
            oprot.writeFieldBegin('entryPoint', TType.STRING, 6)
            oprot.writeString(self.entryPoint.encode('utf-8') if sys.version_info[0] == 2 else self.entryPoint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadDump(object):
    """
    Attributes:
     - limit
     - threadNameList
     - localTraceIdList
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'limit', None, None, ),  # 1
        (2, TType.LIST, 'threadNameList', (TType.STRING, 'UTF8', False), None, ),  # 2
        (3, TType.LIST, 'localTraceIdList', (TType.I64, None, False), None, ),  # 3
    )

    def __init__(self, limit=None, threadNameList=None, localTraceIdList=None,):
        self.limit = limit
        self.threadNameList = threadNameList
        self.localTraceIdList = localTraceIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.threadNameList = []
                    (_etype38, _size35) = iprot.readListBegin()
                    for _i39 in range(_size35):
                        _elem40 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.threadNameList.append(_elem40)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.localTraceIdList = []
                    (_etype44, _size41) = iprot.readListBegin()
                    for _i45 in range(_size41):
                        _elem46 = iprot.readI64()
                        self.localTraceIdList.append(_elem46)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCmdActiveThreadDump')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.threadNameList is not None:
            oprot.writeFieldBegin('threadNameList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.threadNameList))
            for iter47 in self.threadNameList:
                oprot.writeString(iter47.encode('utf-8') if sys.version_info[0] == 2 else iter47)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.localTraceIdList is not None:
            oprot.writeFieldBegin('localTraceIdList', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.localTraceIdList))
            for iter48 in self.localTraceIdList:
                oprot.writeI64(iter48)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadLightDump(object):
    """
    Attributes:
     - limit
     - threadNameList
     - localTraceIdList
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'limit', None, None, ),  # 1
        (2, TType.LIST, 'threadNameList', (TType.STRING, 'UTF8', False), None, ),  # 2
        (3, TType.LIST, 'localTraceIdList', (TType.I64, None, False), None, ),  # 3
    )

    def __init__(self, limit=None, threadNameList=None, localTraceIdList=None,):
        self.limit = limit
        self.threadNameList = threadNameList
        self.localTraceIdList = localTraceIdList

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.threadNameList = []
                    (_etype52, _size49) = iprot.readListBegin()
                    for _i53 in range(_size49):
                        _elem54 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.threadNameList.append(_elem54)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.localTraceIdList = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = iprot.readI64()
                        self.localTraceIdList.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCmdActiveThreadLightDump')
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 1)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.threadNameList is not None:
            oprot.writeFieldBegin('threadNameList', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.threadNameList))
            for iter61 in self.threadNameList:
                oprot.writeString(iter61.encode('utf-8') if sys.version_info[0] == 2 else iter61)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.localTraceIdList is not None:
            oprot.writeFieldBegin('localTraceIdList', TType.LIST, 3)
            oprot.writeListBegin(TType.I64, len(self.localTraceIdList))
            for iter62 in self.localTraceIdList:
                oprot.writeI64(iter62)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadDumpRes(object):
    """
    Attributes:
     - threadDumps
     - type
     - subType
     - version
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'threadDumps', (TType.STRUCT, (TActiveThreadDump, TActiveThreadDump.thrift_spec), False), None, ),  # 1
        (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'subType', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'version', 'UTF8', None, ),  # 4
    )

    def __init__(self, threadDumps=None, type=None, subType=None, version=None,):
        self.threadDumps = threadDumps
        self.type = type
        self.subType = subType
        self.version = version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.threadDumps = []
                    (_etype66, _size63) = iprot.readListBegin()
                    for _i67 in range(_size63):
                        _elem68 = TActiveThreadDump()
                        _elem68.read(iprot)
                        self.threadDumps.append(_elem68)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.subType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCmdActiveThreadDumpRes')
        if self.threadDumps is not None:
            oprot.writeFieldBegin('threadDumps', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.threadDumps))
            for iter69 in self.threadDumps:
                iter69.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.subType is not None:
            oprot.writeFieldBegin('subType', TType.STRING, 3)
            oprot.writeString(self.subType.encode('utf-8') if sys.version_info[0] == 2 else self.subType)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 4)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCmdActiveThreadLightDumpRes(object):
    """
    Attributes:
     - threadDumps
     - type
     - subType
     - version
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'threadDumps', (TType.STRUCT, (TActiveThreadLightDump, TActiveThreadLightDump.thrift_spec), False), None, ),  # 1
        (2, TType.STRING, 'type', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'subType', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'version', 'UTF8', None, ),  # 4
    )

    def __init__(self, threadDumps=None, type=None, subType=None, version=None,):
        self.threadDumps = threadDumps
        self.type = type
        self.subType = subType
        self.version = version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.threadDumps = []
                    (_etype73, _size70) = iprot.readListBegin()
                    for _i74 in range(_size70):
                        _elem75 = TActiveThreadLightDump()
                        _elem75.read(iprot)
                        self.threadDumps.append(_elem75)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.subType = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.version = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCmdActiveThreadLightDumpRes')
        if self.threadDumps is not None:
            oprot.writeFieldBegin('threadDumps', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.threadDumps))
            for iter76 in self.threadDumps:
                iter76.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 2)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        if self.subType is not None:
            oprot.writeFieldBegin('subType', TType.STRING, 3)
            oprot.writeString(self.subType.encode('utf-8') if sys.version_info[0] == 2 else self.subType)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 4)
            oprot.writeString(self.version.encode('utf-8') if sys.version_info[0] == 2 else self.version)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandEcho(object):
    """
    Attributes:
     - message
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    )

    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCommandEcho')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandTransfer(object):
    """
    Attributes:
     - applicationName
     - agentId
     - startTime
     - payload
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'applicationName', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'agentId', 'UTF8', None, ),  # 2
        (3, TType.I64, 'startTime', None, None, ),  # 3
        (4, TType.STRING, 'payload', 'BINARY', None, ),  # 4
    )

    def __init__(self, applicationName=None, agentId=None, startTime=None, payload=None,):
        self.applicationName = applicationName
        self.agentId = agentId
        self.startTime = startTime
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.applicationName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.agentId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startTime = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCommandTransfer')
        if self.applicationName is not None:
            oprot.writeFieldBegin('applicationName', TType.STRING, 1)
            oprot.writeString(self.applicationName.encode('utf-8') if sys.version_info[0] == 2 else self.applicationName)
            oprot.writeFieldEnd()
        if self.agentId is not None:
            oprot.writeFieldBegin('agentId', TType.STRING, 2)
            oprot.writeString(self.agentId.encode('utf-8') if sys.version_info[0] == 2 else self.agentId)
            oprot.writeFieldEnd()
        if self.startTime is not None:
            oprot.writeFieldBegin('startTime', TType.I64, 3)
            oprot.writeI64(self.startTime)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 4)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCommandTransferResponse(object):
    """
    Attributes:
     - routeResult
     - payload
     - message
    """

    thrift_spec = (
        None,  # 0
        (1, TType.I32, 'routeResult', None, None, ),  # 1
        (2, TType.STRING, 'payload', 'BINARY', None, ),  # 2
        (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
    )

    def __init__(self, routeResult=None, payload=None, message=None,):
        self.routeResult = routeResult
        self.payload = payload
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.routeResult = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.payload = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('TCommandTransferResponse')
        if self.routeResult is not None:
            oprot.writeFieldBegin('routeResult', TType.I32, 1)
            oprot.writeI32(self.routeResult)
            oprot.writeFieldEnd()
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRING, 2)
            oprot.writeBinary(self.payload)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
